## ブランチルールを考える

多人数でgitを使う時、一番ミスが起こりやすいのはブランチ操作です。
ブランチのルールを決めることでミスを減らしましょう。

### なにを避けたいか

本番環境にリリースされるのはmasterブランチです。
このmasterブランチに糞を絶対に混ぜてはいけません。
masterブランチは歴史改変を基本的にするべきではないので、
一度間違った状態になったmasterブランチはずっと黒歴史として残ってしまいます。

ブランチ運用で起こしがちなミスを分析し、ミスが起こらないブランチ運用を目指しましょう。
例えばこのようなミスが起こります。

#### 入ってはいけないコードが入る

新しいブランチを作るとき、必ず派生元のブランチがあります。
この派生元のブランチを間違えると大変なことが起こります。

例えば、AブランチからBブランチを作り、Bブランチでひとつの機能を完成させたとします。
Bブランチで作られた機能は十分にテストされているので、安心してmasterにマージするでしょう。
この時、Bブランチだけをマージするつもりが、派生元のAブランチの内容までマージされてしまいます。
もしAブランチが全然未完成だったらどうなるでしょう?

#### 消してはいけないブランチを消してしまう

そんなミスしねえよと思うでしょうが、実際は気をつけないとよく起こります。
例えばリニューアル案件のためにrenewalというブランチを共有していたとします。
一旦入れた開発中のコードを取りやめるときに、developmentブランチと同じ要領でぶっ壊して作りなおしたりしたくなるでしょう。
この時、もし他の人がrenewalはmasterと同じように開発が終わったコードのみを入れるブランチだと思っていたらどうなるでしょう?
もしかしたらrenewalにマージしたブランチはすでに消してしまっているかもしれません。
チーム内で認識の相違があると、いつの間にか他の人のブランチを消してしまうことになってしまいます。

### ブランチルールの例

実際に運用して上手くいったブランチ運用ルールを例として示します。

#### 1. ブランチはmasterから切る

まず、絶対的に *正しいコードはmasterブランチにある* ことを思い出しましょう。

基本的に、 すべてのブランチは **masterブランチから** 切ります。
そうするとそのブランチは、現在動いているコードから、
自分がコミットした以外には何も変更されていないことになります。
もちろん、この状態は変更をテストしやすく、見通しが良い状態です。

#### 2. 全ての変更はトピックブランチにコミットする

**トピックブランチ** とは、ひとまとまりの機能を作るための専用のブランチのことです。
機能ごとに適切な名前のトピックブランチを作り、作業は全てトピックブランチにコミットします。
つまり、 *masterブランチに直接コミットしてはいけない* ということです。

一つのトピックブランチに目的の機能と関係ない変更を加えるのは基本的にしてはいけません。
目的の機能のために、基礎となるクラスに変更を加えるなどの場合、
もしそれがフレームワークの普遍的な部分だとしたら、
やはり別のトピックブランチで作業をする方がいいでしょう。
その場合、フレームワークへの変更を先にmasterにマージし、
トピックブランチをmasterからrebaseします。

#### 3. リモートブランチにも直接コミットしない

**リモートブランチ** とは、他の人と共有しているブランチです。
基本的に他の人と作業を共有するべきではありません。
とは言っても、コードを書くプログラマとhtmlを書くデザイナが協力してひとつの機能を作る、
などのように役割が分担されていたりする場合は、
一つのトピックに二人の作業がコミットされることになります。
このような場合に、トピックブランチをリモートブランチとして共有します。

```
(自分が作る場合)
$ git checkout master
$ git checkout -b topic_master
$ git push origin topic_master # リモートブランチとして共有される

(他の人が作った場合)
$ git checkout -b topic_master origin/topic_master # リモートからローカルにコピー
```

このリモートブランチは、トピック開発という小さな世界のmasterブランチのようなものなので、
masterと同様に直接コミットしてはいけません。
トピックマスターとでも呼ぶことにします。
自分の作業は、トピックマスターから更にトピックブランチを作り、そこにコミットします。
作業が終わったトピックブランチはトピックマスターにマージし、共有します。

```
$ git checkout topic_master
$ git checkout -b topic_A      # 更にトピックブランチを作る
$ (commit)
$ git checkout topic_master
$ git merge --no-ff topic_A    # topic_masterに自分のtopic_Aをマージ
$ git push origin topic_master # 更新をpush
```

#### 4. リモートブランチはいつでも破棄できる

master以外のリモートブランチはいつでも **破棄** してリセットすることができます。
なにかよくわからない状態や試行錯誤のあとが残ってグッチャグチャになった場合、
対処に無駄な時間を使うより、何も考えずに破棄して作りなおしたほうがいいでしょう。
本章のルールは、全体的にリセットとやり直しが容易にできることを目指して作られています。

リモートブランチを作りなおすには次のようにします。

```
$ git push origin :topic_master  # 空のブランチでリモートのtopic_masterを書き換て リモートブランチを消す
$ git checkout master
$ git branch -D topic_master     # マージされてないブランチを強制的に消すのは -D
$ git checkout -b topic_master
$ git push origin topic_master
```

その後、他の人に対して、リモートブランチを作りなおしたことを教えてください。
単純にpullしても上手くいかないので、トピックマスターを消してチェックアウトしなおすか、
次のようにリセットします。

```
$ git fetch --all                       # リモートの情報を更新する
$ git checkout topic_master
$ git reset --hard origin/topic_master  # リモートのtopic_masterブランチにリセット
```

リモートブランチはいつでも破棄される可能性があるので、
開発したトピックブランチは、masterにマージされるまで消してはいけません。
リモートブランチで共有したから、トピックが完了したらきっとまるごと入れるんだろう、
などと期待してはいけません。

masterに入るその日まで、自分がした仕事は自分が責任を持って管理しておきましょう。
消していいブランチは次のコマンドで抽出できます。

```
$ git checkout master
$ git branch --merged
```

#### 5. masterにマージする前に履歴を整理する

開発環境にデプロイすることで発覚した間違いなどは、
トピックブランチに修正コミットを加えることで修正します。
その後、developブランチにトピックブランチをマージし、
修正コミットを適応した状態で再度デプロイします。

この修正コミットは、コミットとして残す意味はないので、
トピックの開発が終わった段階で歴史を改変し、なかったことにします。

```
$ git rebase -i master
```

で、コミット順の変更や、コミットをまとめる( **squash** )などの歴史改変が可能です。

主観的でも全然構わないので、
一つ一つのコミットに意味と意図が見えるように、
コミットの単位を意識して開発しましょう。

#### 6. masterにマージしていいのはトピックブランチだけ

masterにマージしていいのは基本的に個人の手元にあるトピックブランチだけです。
トピックブランチはmasterから切られているので、そのままmasterに戻せばゴミが混ざってないことになります。
developブランチや、トピックマスターなどの共有されたブランチはマージしてはいけません。

例外として、マージ専用に新しく作った共有ブランチならmasterにマージ可とします。
これにより、複数人で開発したトピックマスターと同等のブランチを作ることや、
リリースする内容を一旦まとめた **releaseブランチ** を作って、それをmasterにマージすることができます。

#### 7. トピックブランチをマージするときは --no-ff

トピックブランチが、最新のmasterからいくつかコミットが追加された状態のとき、 **fast-forward** な状態と言います。
fast-forwardなブランチはマージしやすく、見通しはいいのですが、一つ重大な問題があります。

fast-forwardなトピックブランチをmasterにマージすると、
あたかもmasterがトピックブランチの場所に移動しただけの状態になり、
その開発にトピックブランチがあったことが忘れ去られてしまいます。

それを防ぐために、トピックブランチをマージするときは --no-ff オプションを使います。
マージ自体がひとつのコミットとして扱われます。
```
$ git checkout master
$ git merge --no-ff topic_A
```

リリースブランチなどにトピックブランチをマージする場合も、 --no-ff をつけます。
その後、リリースブランチ自体をmasterにマージするときは、つけないほうがいいでしょう。
リリースブランチは、それが存在した意味は無いからです。

```
$ git checkout release
$ git merge --no-ff topic_A
$ git merge --no-ff topic_B
$ git checkout master
$ git merge release
```

なお、githubでPullRequestをマージすると --no-ff と同じ処理がされます。
なので、githubでPullRequestベースで開発をするときは、リリースブランチをPullRequestするような方法はあまり推奨しません。
